# MVCCoreTutorial

**Model-view-controller**

**Model**
<br />This is where data and business logic is stored.

**View**
<br />The View is the actual visual representation of your Model

**Controller**
<br />The Controller should handle all communication between your Model and your View.

**ASP.NET MVC View Engine**
<br />WebForms are old and Razor view engine is the most commonly used view engine.


**.NET Core**
<br />You know what this is.

<br />
<br />

**Controller**
<br />Right click and add a Controller. Scaffolding is your friend.
<br />It looks like a regular C# class. It inherits the Controller class, which is how the .NET frameworks know that this class is to be treated as an MVC Controller. It has one method called Index(), which will try to return the default view by calling the View() method.

```csharp
using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace MVCCoreTutorial.Controllers
{
	public class YoloController : Controller
	{
		public IActionResult Index()
		{
			return View();
		}
	}
}
```



<br />
<br />

**View**
<br />Right click and add a View to your folder based on the controller we are using.
<br />Basic HTML with some Razor at the top.

```html
@{
    ViewData["Title"] = "Yolo";
}

<div class="text-center">
    <h1 class="display-4">Yolo</h1>
    <p>yolo..</p>
</div>
```



<br />
<br />

**Model**
<br />In the MVC architecture, the Model is generated by the Controller and then passed to the View, which outputs the relevant data to the user.
<br />Model can be any kind of object found in the framework. It could in fact be a simple number or string, or it could be a complex object instantiated from a class, e.g. a User class which holds information about a user, a GuestbookEntry item which contains a post to a guestbook or anything else. That also means that your Model can be a class you already have, e.g. something that comes from the database, or a class that you create specifically to become a Model for one or several Views.
<br />Right click and add a regular class to your folder.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace MVCCoreTutorial.Models
{
	public class Yolo
	{	
		public int ID { get; set; }
		public string YoloMessage { get; set; }
	}
}
```

<br />the Model should be instantiated by the Controller and returned with the view.

```csharp
public IActionResult Index()
{
    return View();
}
```

<br />We now return the model with the view.

```csharp
public IActionResult Index()
{
	Yolo yolo = new Yolo();

	yolo.ID = 1;
	yolo.YoloMessage = "Yo only live oop";

	return View(yolo);
}
```


<br />a View can work without a Model just fine, but when we want to actually use a Model, we need to make the View aware of this and tell it which type we expect the Model to be. This is done with the Razor @model directive.

```csharp
@model MVCCoreTutorial.Models.Yolo
```



<br />Now we can use the @Model object to access the properties of the Model sent through.
<br /> NOTE: The M in Model must be capitalised and @model must be lower case. You will get errors if not.

```html

@model MVCCoreTutorial.Models.Yolo

@{
    ViewData["Title"] = "Yolo";
}

<div class="text-center">
    <h1 class="display-4">Yolo</h1>
    <p>yolo..</p>

    @Model.ID

    <br />

    @Model.YoloMessage

</div>

```

<br />
<br />

**Razor**
<br />Razor allows you to write in various "dialects", based on your favorite .NET language. 
<br />The biggest advantage of the Razor is the fact that you can mix client-side markup (HTML) with server-side code (e.g C# or VB.NET), without having to explicitly jump in and out of the two syntax types.
<br />
<br />
**HTML Encoding**
<br />Use the @Html.Raw() method to render raw html. Like JQuery html().
<br />Create a variable and use it in the Html.
```html
@{
    var HtmlMessage = "<b>this is a messgae.</b>";
}

<div class="text-center">
    
    @HtmlMessage

    <br />
    
    @Html.Raw(HtmlMessage)

</div>
```

<br />Output:

```html
<b>this is a messgae.</b>
this is a messgae.
```

<br />
<br />

**Explicit expressions**
<br /> Razor comes with an explicit expression syntax for just those situations and basically it's all about wrapping your expression with a set of parentheses. This makes it easier for the parser to understand what you're doing, and allows for stuff like calculations and modifications inside of a Razor expression.
```html
@{
    var HtmlMessage = "<b>this is a messgae.</b>";
}

<div class="text-center">

    @(1 + 1)

    <br />

    @(HtmlMessage.Length)

</div>
```

<br />Output:

```html
2
25
```


<br />
<br />

**Multi-statement Razor blocks**
<br />Razor allows you to enter a dedicated, multiline code-block by entering a start curly-bracket after the @-operator.

```html
@{
    var MultiMessage = "This is a multi message";
}

@MultiMessage
```

<br />Output:

```html
This is a multi message
```


<br />
<br />



<br />
<br />

**HTML tags and plain text inside code blocks**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:

```html
@{
    var MultiMessage = "This is a multi message";

    <p>This is markup @MultiMessage</p>

}

@MultiMessage
```

<br />Output:

```html
This is markup This is a multi message

This is a multi message
```

<br />
<br />

If you want plain text in code block use the @: operator: This will return the text with not parsing it through markup.
<br />Also if you want multiple lines of plain text, use the "text" tag.

```html
@{
    @:This is plain text!
  
    <text>This is plain text as well, and we can
    even span multiple lines, if needed!</text>
}
```

<br />
<br />

**Razor server-side comments**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:
<br />
<br />
Inside Views
```html
@*
    Here's a Razor server-side comment
    It won't be rendered to the browser
    It can span multiple lines
*@
```

<br />
<br />

Inside Code Blocks
```csharp
@{
    @*
    Here's a Razor server-side comment
    *@

    // C# style single-line comment

    /* 
    C# style multiline comment
    It can span multiple lines
    */    
}
```

<br />
<br />

**Razor variables**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:
<br />
<br />
Just like you would in C#.
```csharp
@{ 
    string helloWorldMsg = "Good day";
    if(DateTime.Now.Hour > 17)
    {
    helloWorldMsg = "Good evening";
    }
    helloWorldMsg += ", world!";
    helloWorldMsg = helloWorldMsg.ToUpper();
}

<div>
    @helloWorldMsg
</div>
```

<br />
<br />

**Razor IF Statements**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:
<br />
<br />
Just like you would in C#. 
```csharp
@if(DateTime.Now.Year >= 2042)
{
    <span>The year 2042 has finally arrived!</span>
}
else
{
    <span>We're still waiting for the year of 2042...</span>
}
```

<br />
<br />

**Razor "for" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

<ul>
    @for (int i = 0; i < list.Count; i++)
    {
        <li>@list[i]</li>
    }
</ul>
```

<br />
<br />

**Razor "foreach" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

<ul>
    @foreach (string i in list)
    {
        <li>@i</li>
    }
</ul>
```

<br />
<br />

**Razor "while" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

@{
    int i = 0;
}

<ul>
    @while (i < list.Count)
    {
        <li>@list[i++]</li>
    }
</ul>
```

<br />
<br />

**Razor "do while" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

@{
    int j = 0;
}

<ul>
    @do 
    {
        <li>@list[j++]</li>
    } while (j < list.Count);
</ul>
```

<br />
<br />

**Razor "break/continue" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

<ul>
    @for (int l = 0; l < list.Count; l++)
    {
        <li>@list[l]</li>

        @if (l >= 2)
        {
            <li>...and so on</li>

            break;
        }
    }
</ul>
```

<br />
<br />

**Razor Switch Case**
<br />
<br />
Just like you would in C#. 
```csharp
@switch(DateTime.Now.DayOfWeek)
{
    case DayOfWeek.Monday:
        <span>Uh-oh...</span>
		break;
	case DayOfWeek.Friday:
		<span>Weekend coming up!</span>
		break;
	case DayOfWeek.Saturday:
	case DayOfWeek.Sunday:
		<span>Finally weekend!</span>
		break;
	default:
		<span>Nothing special about this day...</span>
		break;
}
```

<br />
<br />

**Razor Local Functions**
<br />
<br />
You can use these code blocks for pretty much anything that C# can do - you can even define local functions!
```csharp
@{
    void RenderTitleName()
    {
        <div>
            This is rendered from a function.
        </div>
    }

    int AnswerToLife(int x, int y)
    {
        return x * y;
    }
}

@{
    RenderTitleName();
}

<div>
    The answer to life: @AnswerToLife(7, 6)
</div>
```

<br />
<br />

**Razor Templated delegates**
<br />
<br />
The templated delegates functionality in Razor allows you to define a piece of markup and then have it used to represent a specific object on the page.
```csharp
@{
    Func<dynamic, object> YoloTemplate = @<div>@item.ID: @item.YoloMessage</div>;

    List<Yolo> yoloList = new List<Yolo>();

    Yolo y = new Yolo();
    y.ID = 12;
    y.YoloMessage = "this is me";
    yoloList.Add(y);

    y = new Yolo();
    y.ID = 42;
    y.YoloMessage = "Another time";
    yoloList.Add(y);
}


@foreach (Yolo yy in yoloList)
{
    @YoloTemplate(yy);
}
```

<br />
<br />

**Controllers**
<br />
<br />
In ASP.NET MVC, a Controller is just like any other class, so it has a .cs file extension (or .vb, if you use Visual Basic) and looks like any other .NET class. However, there are a few things that will allow you (and the .NET framework) to recognize it as an MVC Controller.
<br />
* It's usually placed in a folder called "Controllers" in the root of your project
* It inherits from Microsoft.AspNetCore.Mvc.Controller (or from one of your own classes which then inherits the Microsoft.AspNetCore.Mvc.Controller class)
* The name of the class will usually end with the word Controller, e.g. "HomeController" or "ProductsController"
<br />
<br />
The **[Controller]** attribute can be placed right before a class declaration to define it as a Controller.

<br />
<br />

**Controller Actions**
<br />
<br />
Methods of a Controller class is referred to as actions - a method usually corresponds to an action in your application, which then returns something to the browser/user.
<br />
Routing is what connects URL's to actions on your Controllers.
<br />
All public methods on a Controller class is considered an Action.
<br />
If you really need a method to be public but not accessible by URL, you can mark the method with the [NonAction] attribute.

<br />
<br />

**Action Verbs**
<br />
<br />
These are in fact regular .NET attributes, which will tell the .NET framework how an action can be accessed.
<br />
<br />

```csharp
[HttpGet]
public IActionResult Edit()
{
    return View();
}

[HttpPost]
public IActionResult Edit(Product product)
{
    product.Save();
    return Content("Product updated!");
}
```

<br />
<br />

In some situations, you may want to specify multiple Action Verbs, e.g. to specify that an action can be accessed by both POST and GET requests but not other types.

<br />
<br />

```csharp
[HttpGet]
[HttpPost]
public IActionResult Edit()
{
    return View();
}
```

<br />
<br />

**Action Results**
<br />
<br />
When the Action (method) finishes it work, it will usually return something to the client and that something will usually be implementing the IActionResult interface (or Task IActionResult if the method is asynchronous).
<br />
<br />
A view is far from the only possible result of a Controller action, though. Since the result will eventually be returned to a browser, the available methods should cover all possible outcomes of a HTTP request, so a Controller action can of course also result in a redirect, a 404 (Page not Found) or any of the other HTTP status codes. Here's an incomplete list of the most interesting and useful methods for generating an Action result:
<br />
* **Content()** - returns the specified string as plain text to the client (usually a browser)
* **View()** - returns a View to the client
* **PartialView()** - returns a Partial View (more on those elsewhere in this tutorial) to the client
* **File()** - returns the content of a specified file to the client
* **Json()** - returns a JSON response to the client
* **Redirect()** and RedirectPermanent() - returns a redirect response to the browser (temporary or permanent), redirecting the user to another URL
* **StatusCode()** - returns a custom status code to the client
<br />
<br />
 If the product is found, we return it inside of a View using the View() method - if not, we return a 404 error using the NotFound() helper method, which basically just creates an instance of the NotFoundResult class.
<br />

```csharp
public IActionResult Details(int id)  
{  
	Product product = GetProduct(id);
	if (product != null)  
        {
            return View(product);  
        }
        else
        {
	        return NotFound();  
        }
}
```

<br />
<br />

**Views**
<br />
<br />
A View contains markup (HTML) and Razor code and will often be a visual representation of your Model.
<br />
The Controller generates a Model object and then passes it to the View, which then uses the Model to visually represent the content of the Model to the user.
<br />

<br />
<br />

**View Discovery: Connecting Controller & View**
<br />
<br />
View Discovery - a process where ASP.NET MVC will try to guess which View to use, without forcing you to specify it.
<br />
View Discovery works when you follow a certain convention when creating your project structure.
<br />
```csharp
/Views/[Controller Name]/[Action Name].cshtml
```

<br />
<br />

you can simply call the View() method from your Controller actions and have the .NET framework automatically locate the proper View for you:

<br />

```csharp
public class ProductController : Controller
{
    public IActionResult Index()
    {
        return View();
    }

    public IActionResult Details()
    {
        return View();
    }
}
```

<br />
<br />

If the framework can't find a matching View using the convention mentioned above, it will look in one more place:

<br />

```csharp
/Views/Shared/[Action Name].cshtml
```

<br />
<br />

**Specifying a View**
<br />
<br />
Supply the View name.
<br />

```csharp
public IActionResult Test()
{
    return View("Details");
}
```

<br />

Specify the file path of the View
<br />

```csharp
public IActionResult Test()
{
    return View("/ViewFolderName/SomeFolderName/ViewName.cshtml");
}
```

<br />
<br />

**Passing data into Views**
<br />
<br />
Since your View shouldn't have to know about your Controller (as per the rule of separation of concerns), your Controller is responsible for making the data available to the View. There are two main ways of doing this: Either you define a strongly typed Model and then pass it to the View, or you can use the ViewData/ViewBag containers to make data available to the View.
<br />

```csharp
public IActionResult Details(int id)
{
    Product product = new Product()
    {
        Title = "Toilet Paper",
        Price = 1.99
    };
    return View(product);
}
```
<br />
<br />

```html
@model HelloMVCWorld.Models.Product

<h1>@Model.Title</h1>
Price: @Model.Price
```

<br />
<br />

**ViewData/ViewBag containers**
<br />
<br />
As an alternative to the strongly typed approach to passing data to a View, you can use the so-called ViewData/ViewBag containers. You can add stuff to them from the Controller and then automatically be able to access the stored data in your Views.
<br />

```csharp
public IActionResult DetailsViewData(int id)
{
    ViewData["ProductTitle"] = "Toilet Paper";
    ViewBag.ProductPrice = 1.99;
    return View();
}
```
<br />
<br />

```html
<h1>@ViewData["ProducTtitle"]</h1>
Price: @ViewBag.ProductPrice
```

<br />
<br />

**Partial Views**
<br />
<br />
Partial views are regular views which are shown in other views. Create a view on the shared folder.
<br />
Use one of the methods of the Html Helper object found in the MVC framework called **PartialAsync()**.
<br />

```csharp
@await Html.PartialAsync("_Greeting")
```
<br />
<br />

**Passing data into Partial Views**
<br />
<br />
Since a Partial View is basically just a regular View, you have the same options if you need access to data in your Partial View. You can use a strongly typed Model (e.g. the same Model used in the parent View) or custom data through a ViewDataDictionary instance or even a combination of both.

<br />
<br />

```csharp
@for (int i = 0; i < 3; i++)
{
    @await Html.PartialAsync("_Greeting", Model, new ViewDataDictionary(ViewData) { { "index", i } })
}
```

<br />
<br />

```html
<span>
    Iteration number @ViewData["index"]
</span>
```

<br />
<br />

**Layout**
<br />
<br />
In ASP.NET MVC, you can use something called a Layout, often in combination with Sections. You can have one or several Layouts in your project and each can include zero or more Sections.

<br />
<br />

**Layout Files**
<br />
<br />
Notice how it's almost just a regular HTML file, except for the **RenderBody()** Razor method. This part is required in a Layout file, because it specifies where the content of the page using the Layout should be placed.

<br />
<br />

**_Layout.cshtml**

```html
<!DOCTYPE html>
<html>
<head>    
    <title>Layout</title>
</head>
<body>

    @RenderBody()

</body>
</html>
```

<br />
<br />

**LayoutTest.cshtml**

```html
@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<p>Hello, world!</p>
```

<br />
<br />

**The ViewStart file**
<br />
<br />
ASP.NET MVC will automatically look for a ViewStart file and interpret it before it interprets the actual page/view.

```html
@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}
```

<br />
<br />

**Sections**
<br />
<br />
Add a RenderSection() call to our existing Layout file.

```html
<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>_Layout</title>
</head>
<body>

    @RenderBody()
    
    <p>Lots of Layout content goes here...</p>

    @RenderSection("Footer")

</body>
</html>
```
<br />

Then add a @section code block to the view to define the section.

```html
@section Footer {
    Hello from the About page!
}
```

<br />
<br />

**Optional Sections**
<br />
<br />
By default, all sections are required, just like the body is.

```html
@RenderSection("Footer", required : false)
```

<br />
<br />

**The ViewImports file**
<br />
<br />
Just like the _ViewStart.cshtml file, the _ViewImports.cshtml file is invoked for all your Views, before they are rendered. It allows you to define common functionality and imports, e.g. the already mentioned using statements.

```html
@using
@inject
@model
@inherits
@addTagHelper
@removeTagHelper
@tagHelperPrefix
```
<br />
<br />




<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

