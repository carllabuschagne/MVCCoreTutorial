# MVCCoreTutorial

**Model-view-controller**

**Model**
<br />This is where data and business logic is stored.

**View**
<br />The View is the actual visual representation of your Model

**Controller**
<br />The Controller should handle all communication between your Model and your View.

**ASP.NET MVC View Engine**
<br />WebForms are old and Razor view engine is the most commonly used view engine.


**.NET Core**
<br />You know what this is.

<br />
<br />

**Controller**
<br />Right click and add a Controller. Scaffolding is your friend.
<br />It looks like a regular C# class. It inherits the Controller class, which is how the .NET frameworks know that this class is to be treated as an MVC Controller. It has one method called Index(), which will try to return the default view by calling the View() method.

```csharp
using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace MVCCoreTutorial.Controllers
{
	public class YoloController : Controller
	{
		public IActionResult Index()
		{
			return View();
		}
	}
}
```



<br />
<br />

**View**
<br />Right click and add a View to your folder based on the controller we are using.
<br />Basic HTML with some Razor at the top.

```html
@{
    ViewData["Title"] = "Yolo";
}

<div class="text-center">
    <h1 class="display-4">Yolo</h1>
    <p>yolo..</p>
</div>
```



<br />
<br />

**Model**
<br />In the MVC architecture, the Model is generated by the Controller and then passed to the View, which outputs the relevant data to the user.
<br />Model can be any kind of object found in the framework. It could in fact be a simple number or string, or it could be a complex object instantiated from a class, e.g. a User class which holds information about a user, a GuestbookEntry item which contains a post to a guestbook or anything else. That also means that your Model can be a class you already have, e.g. something that comes from the database, or a class that you create specifically to become a Model for one or several Views.
<br />Right click and add a regular class to your folder.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace MVCCoreTutorial.Models
{
	public class Yolo
	{	
		public int ID { get; set; }
		public string YoloMessage { get; set; }
	}
}
```

<br />the Model should be instantiated by the Controller and returned with the view.

```csharp
public IActionResult Index()
{
    return View();
}
```

<br />We now return the model with the view.

```csharp
public IActionResult Index()
{
	Yolo yolo = new Yolo();

	yolo.ID = 1;
	yolo.YoloMessage = "Yo only live oop";

	return View(yolo);
}
```


<br />a View can work without a Model just fine, but when we want to actually use a Model, we need to make the View aware of this and tell it which type we expect the Model to be. This is done with the Razor @model directive.

```csharp
@model MVCCoreTutorial.Models.Yolo
```



<br />Now we can use the @Model object to access the properties of the Model sent through.
<br /> NOTE: The M in Model must be capitalised and @model must be lower case. You will get errors if not.

```html

@model MVCCoreTutorial.Models.Yolo

@{
    ViewData["Title"] = "Yolo";
}

<div class="text-center">
    <h1 class="display-4">Yolo</h1>
    <p>yolo..</p>

    @Model.ID

    <br />

    @Model.YoloMessage

</div>

```

<br />
<br />

**Razor**
<br />Razor allows you to write in various "dialects", based on your favorite .NET language. 
<br />The biggest advantage of the Razor is the fact that you can mix client-side markup (HTML) with server-side code (e.g C# or VB.NET), without having to explicitly jump in and out of the two syntax types.
<br />
<br />
**HTML Encoding**
<br />Use the @Html.Raw() method to render raw html. Like JQuery html().
<br />Create a variable and use it in the Html.
```html
@{
    var HtmlMessage = "<b>this is a messgae.</b>";
}

<div class="text-center">
    
    @HtmlMessage

    <br />
    
    @Html.Raw(HtmlMessage)

</div>
```

<br />Output:

```html
<b>this is a messgae.</b>
this is a messgae.
```

<br />
<br />

**Explicit expressions**
<br /> Razor comes with an explicit expression syntax for just those situations and basically it's all about wrapping your expression with a set of parentheses. This makes it easier for the parser to understand what you're doing, and allows for stuff like calculations and modifications inside of a Razor expression.
```html
@{
    var HtmlMessage = "<b>this is a messgae.</b>";
}

<div class="text-center">

    @(1 + 1)

    <br />

    @(HtmlMessage.Length)

</div>
```

<br />Output:

```html
2
25
```


<br />
<br />

**Multi-statement Razor blocks**
<br />Razor allows you to enter a dedicated, multiline code-block by entering a start curly-bracket after the @-operator.

```html
@{
    var MultiMessage = "This is a multi message";
}

@MultiMessage
```

<br />Output:

```html
This is a multi message
```


<br />
<br />



<br />
<br />

**HTML tags and plain text inside code blocks**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:

```html
@{
    var MultiMessage = "This is a multi message";

    <p>This is markup @MultiMessage</p>

}

@MultiMessage
```

<br />Output:

```html
This is markup This is a multi message

This is a multi message
```

<br />
<br />

If you want plain text in code block use the @: operator: This will return the text with not parsing it through markup.
<br />Also if you want multiple lines of plain text, use the "text" tag.

```html
@{
    @:This is plain text!
  
    <text>This is plain text as well, and we can
    even span multiple lines, if needed!</text>
}
```

<br />
<br />

**Razor server-side comments**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:
<br />
<br />
Inside Views
```html
@*
    Here's a Razor server-side comment
    It won't be rendered to the browser
    It can span multiple lines
*@
```

<br />
<br />

Inside Code Blocks
```csharp
@{
    @*
    Here's a Razor server-side comment
    *@

    // C# style single-line comment

    /* 
    C# style multiline comment
    It can span multiple lines
    */    
}
```

<br />
<br />

**Razor variables**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:
<br />
<br />
Just like you would in C#.
```csharp
@{ 
    string helloWorldMsg = "Good day";
    if(DateTime.Now.Hour > 17)
    {
    helloWorldMsg = "Good evening";
    }
    helloWorldMsg += ", world!";
    helloWorldMsg = helloWorldMsg.ToUpper();
}

<div>
    @helloWorldMsg
</div>
```

<br />
<br />

**Razor IF Statements**
<br />Razor allows you to mix in HTML tags directly in your code blocks, like this:
<br />
<br />
Just like you would in C#. 
```csharp
@if(DateTime.Now.Year >= 2042)
{
    <span>The year 2042 has finally arrived!</span>
}
else
{
    <span>We're still waiting for the year of 2042...</span>
}
```

<br />
<br />

**Razor "for" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

<ul>
    @for (int i = 0; i < list.Count; i++)
    {
        <li>@list[i]</li>
    }
</ul>
```

<br />
<br />

**Razor "foreach" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

<ul>
    @foreach (string i in list)
    {
        <li>@i</li>
    }
</ul>
```

<br />
<br />

**Razor "while" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

@{
    int i = 0;
}

<ul>
    @while (i < list.Count)
    {
        <li>@list[i++]</li>
    }
</ul>
```

<br />
<br />

**Razor "do while" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

@{
    int j = 0;
}

<ul>
    @do 
    {
        <li>@list[j++]</li>
    } while (j < list.Count);
</ul>
```

<br />
<br />

**Razor "break/continue" loop**
<br />
<br />
Just like you would in C#. 
```csharp
@{
    List<string> list = new List<string>();
    list.Add("Dave");
    list.Add("Mike");
    list.Add("Chuck");
}

<ul>
    @for (int l = 0; l < list.Count; l++)
    {
        <li>@list[l]</li>

        @if (l >= 2)
        {
            <li>...and so on</li>

            break;
        }
    }
</ul>
```

<br />
<br />

**Razor Switch Case**
<br />
<br />
Just like you would in C#. 
```csharp
@switch(DateTime.Now.DayOfWeek)
{
    case DayOfWeek.Monday:
        <span>Uh-oh...</span>
		break;
	case DayOfWeek.Friday:
		<span>Weekend coming up!</span>
		break;
	case DayOfWeek.Saturday:
	case DayOfWeek.Sunday:
		<span>Finally weekend!</span>
		break;
	default:
		<span>Nothing special about this day...</span>
		break;
}
```

<br />
<br />

**Razor Local Functions**
<br />
<br />
You can use these code blocks for pretty much anything that C# can do - you can even define local functions!
```csharp
@{
    void RenderTitleName()
    {
        <div>
            This is rendered from a function.
        </div>
    }

    int AnswerToLife(int x, int y)
    {
        return x * y;
    }
}

@{
    RenderTitleName();
}

<div>
    The answer to life: @AnswerToLife(7, 6)
</div>
```

<br />
<br />

**Razor Templated delegates**
<br />
<br />
The templated delegates functionality in Razor allows you to define a piece of markup and then have it used to represent a specific object on the page.
```csharp
@{
    Func<dynamic, object> YoloTemplate = @<div>@item.ID: @item.YoloMessage</div>;

    List<Yolo> yoloList = new List<Yolo>();

    Yolo y = new Yolo();
    y.ID = 12;
    y.YoloMessage = "this is me";
    yoloList.Add(y);

    y = new Yolo();
    y.ID = 42;
    y.YoloMessage = "Another time";
    yoloList.Add(y);
}


@foreach (Yolo yy in yoloList)
{
    @YoloTemplate(yy);
}
```

<br />
<br />

**Controllers**
<br />
<br />
In ASP.NET MVC, a Controller is just like any other class, so it has a .cs file extension (or .vb, if you use Visual Basic) and looks like any other .NET class. However, there are a few things that will allow you (and the .NET framework) to recognize it as an MVC Controller.
<br />
* It's usually placed in a folder called "Controllers" in the root of your project
* It inherits from Microsoft.AspNetCore.Mvc.Controller (or from one of your own classes which then inherits the Microsoft.AspNetCore.Mvc.Controller class)
* The name of the class will usually end with the word Controller, e.g. "HomeController" or "ProductsController"
<br />
<br />
The **[Controller]** attribute can be placed right before a class declaration to define it as a Controller.

<br />
<br />

**Controller Actions**
<br />
<br />
Methods of a Controller class is referred to as actions - a method usually corresponds to an action in your application, which then returns something to the browser/user.
<br />
Routing is what connects URL's to actions on your Controllers.
<br />
All public methods on a Controller class is considered an Action.
<br />
If you really need a method to be public but not accessible by URL, you can mark the method with the [NonAction] attribute.

<br />
<br />

**Action Verbs**
<br />
<br />
These are in fact regular .NET attributes, which will tell the .NET framework how an action can be accessed.
<br />
<br />

```csharp
[HttpGet]
public IActionResult Edit()
{
    return View();
}

[HttpPost]
public IActionResult Edit(Product product)
{
    product.Save();
    return Content("Product updated!");
}
```

<br />
<br />

In some situations, you may want to specify multiple Action Verbs, e.g. to specify that an action can be accessed by both POST and GET requests but not other types.

<br />
<br />

```csharp
[HttpGet]
[HttpPost]
public IActionResult Edit()
{
    return View();
}
```

<br />
<br />

**Action Results**
<br />
<br />
When the Action (method) finishes it work, it will usually return something to the client and that something will usually be implementing the IActionResult interface (or Task IActionResult if the method is asynchronous).
<br />
<br />
A view is far from the only possible result of a Controller action, though. Since the result will eventually be returned to a browser, the available methods should cover all possible outcomes of a HTTP request, so a Controller action can of course also result in a redirect, a 404 (Page not Found) or any of the other HTTP status codes. Here's an incomplete list of the most interesting and useful methods for generating an Action result:
<br />
* **Content()** - returns the specified string as plain text to the client (usually a browser)
* **View()** - returns a View to the client
* **PartialView()** - returns a Partial View (more on those elsewhere in this tutorial) to the client
* **File()** - returns the content of a specified file to the client
* **Json()** - returns a JSON response to the client
* **Redirect()** and RedirectPermanent() - returns a redirect response to the browser (temporary or permanent), redirecting the user to another URL
* **StatusCode()** - returns a custom status code to the client
<br />
<br />
 If the product is found, we return it inside of a View using the View() method - if not, we return a 404 error using the NotFound() helper method, which basically just creates an instance of the NotFoundResult class.
<br />

```csharp
public IActionResult Details(int id)  
{  
	Product product = GetProduct(id);
	if (product != null)  
        {
            return View(product);  
        }
        else
        {
	        return NotFound();  
        }
}
```

<br />
<br />

**Views**
<br />
<br />
A View contains markup (HTML) and Razor code and will often be a visual representation of your Model.
<br />
The Controller generates a Model object and then passes it to the View, which then uses the Model to visually represent the content of the Model to the user.
<br />

<br />
<br />

**View Discovery: Connecting Controller & View**
<br />
<br />
View Discovery - a process where ASP.NET MVC will try to guess which View to use, without forcing you to specify it.
<br />
View Discovery works when you follow a certain convention when creating your project structure.
<br />
```csharp
/Views/[Controller Name]/[Action Name].cshtml
```

<br />
<br />

you can simply call the View() method from your Controller actions and have the .NET framework automatically locate the proper View for you:

<br />

```csharp
public class ProductController : Controller
{
    public IActionResult Index()
    {
        return View();
    }

    public IActionResult Details()
    {
        return View();
    }
}
```

<br />
<br />

If the framework can't find a matching View using the convention mentioned above, it will look in one more place:

<br />

```csharp
/Views/Shared/[Action Name].cshtml
```

<br />
<br />

**Specifying a View**
<br />
<br />
Supply the View name.
<br />

```csharp
public IActionResult Test()
{
    return View("Details");
}
```

<br />

Specify the file path of the View
<br />

```csharp
public IActionResult Test()
{
    return View("/ViewFolderName/SomeFolderName/ViewName.cshtml");
}
```

<br />
<br />

**Passing data into Views**
<br />
<br />
Since your View shouldn't have to know about your Controller (as per the rule of separation of concerns), your Controller is responsible for making the data available to the View. There are two main ways of doing this: Either you define a strongly typed Model and then pass it to the View, or you can use the ViewData/ViewBag containers to make data available to the View.
<br />

```csharp
public IActionResult Details(int id)
{
    Product product = new Product()
    {
        Title = "Toilet Paper",
        Price = 1.99
    };
    return View(product);
}
```
<br />
<br />

```html
@model HelloMVCWorld.Models.Product

<h1>@Model.Title</h1>
Price: @Model.Price
```

<br />
<br />

**ViewData/ViewBag containers**
<br />
<br />
As an alternative to the strongly typed approach to passing data to a View, you can use the so-called ViewData/ViewBag containers. You can add stuff to them from the Controller and then automatically be able to access the stored data in your Views.
<br />

```csharp
public IActionResult DetailsViewData(int id)
{
    ViewData["ProductTitle"] = "Toilet Paper";
    ViewBag.ProductPrice = 1.99;
    return View();
}
```
<br />
<br />

```html
<h1>@ViewData["ProducTtitle"]</h1>
Price: @ViewBag.ProductPrice
```

<br />
<br />

**Partial Views**
<br />
<br />
Partial views are regular views which are shown in other views. Create a view on the shared folder.
<br />
Use one of the methods of the Html Helper object found in the MVC framework called **PartialAsync()**.
<br />

```csharp
@await Html.PartialAsync("_Greeting")
```
<br />
<br />

**Passing data into Partial Views**
<br />
<br />
Since a Partial View is basically just a regular View, you have the same options if you need access to data in your Partial View. You can use a strongly typed Model (e.g. the same Model used in the parent View) or custom data through a ViewDataDictionary instance or even a combination of both.

<br />
<br />

```csharp
@for (int i = 0; i < 3; i++)
{
    @await Html.PartialAsync("_Greeting", Model, new ViewDataDictionary(ViewData) { { "index", i } })
}
```

<br />
<br />

```html
<span>
    Iteration number @ViewData["index"]
</span>
```

<br />
<br />

**Layout**
<br />
<br />
In ASP.NET MVC, you can use something called a Layout, often in combination with Sections. You can have one or several Layouts in your project and each can include zero or more Sections.

<br />
<br />

**Layout Files**
<br />
<br />
Notice how it's almost just a regular HTML file, except for the **RenderBody()** Razor method. This part is required in a Layout file, because it specifies where the content of the page using the Layout should be placed.

<br />
<br />

**_Layout.cshtml**

```html
<!DOCTYPE html>
<html>
<head>    
    <title>Layout</title>
</head>
<body>

    @RenderBody()

</body>
</html>
```

<br />
<br />

**LayoutTest.cshtml**

```html
@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<p>Hello, world!</p>
```

<br />
<br />

**The ViewStart file**
<br />
<br />
ASP.NET MVC will automatically look for a ViewStart file and interpret it before it interprets the actual page/view.

```html
@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}
```

<br />
<br />

**Sections**
<br />
<br />
Add a RenderSection() call to our existing Layout file.

```html
<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>_Layout</title>
</head>
<body>

    @RenderBody()
    
    <p>Lots of Layout content goes here...</p>

    @RenderSection("Footer")

</body>
</html>
```
<br />

Then add a @section code block to the view to define the section.

```html
@section Footer {
    Hello from the About page!
}
```

<br />
<br />

**Optional Sections**
<br />
<br />
By default, all sections are required, just like the body is.

```html
@RenderSection("Footer", required : false)
```

<br />
<br />

**The ViewImports file**
<br />
<br />
Just like the _ViewStart.cshtml file, the _ViewImports.cshtml file is invoked for all your Views, before they are rendered. It allows you to define common functionality and imports, e.g. the already mentioned using statements.

```html
@using
@inject
@model
@inherits
@addTagHelper
@removeTagHelper
@tagHelperPrefix
```

<br />
<br />

**Routing**
<br />
<br />
Routing in MVC is the concept of mapping a URL, which is what the end-user will be requesting through their browser, to a method in one of your controllers, which will then send a response back to the browser. i.e. View, Json, Text, etc

```csharp
app.UseRouting();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

Here are some examples of URL's that now works and the Controller/Method combination that they map to:

```csharp
http://localhost/           ->      HomeController.Index()  
http://localhost/Home/Index     ->      HomeController.Index()  
http://localhost/Test/      ->      HomeController.Test()  
http://localhost/Home/Something ->      HomeController.Something()
```

<br />
<br />

**The anatomy of an MVC Route**
<br />
<br />
The call to MapRoute() takes several parameters - in this case, we supply a name for the route (the first parameter), the URL template for the rule (the second parameter), as well as an object of "defaults" (the third parameter), which will direct the rule to the desired Controller and method on that Controller. So, with this in place, we can now call the URL http://localhost/Products/List, and the List() method on the ProductsController will be called.
```csharp
app.UseMvc(routes =>
    routes.MapRoute("ProductList", "Products/List/", new { controller = "Products", action = "List" })
);
```
<br />

We now support the following URL's:

* /Products/
* /Products/List/
* /Products/Details/32/

<br />

Our Controller could look like this.

```csharp
public class ProductsController : Controller
{
    public IActionResult Index()
    {
        return Content("Product overview");
    }
    
    public IActionResult List()
    {
        return Content("Product list");
    }

    public IActionResult Details(int id)
    {
        return Content("Product details for #" + id);
    }
}
```

<br />

Notice especially the Details methods - it has a parameter called "id", which matches the parameter we specified in the route. This means that if you call the Details URL, the ID you append to it will automatically be passed as the id parameter to the Details method!

<br />

**Multiple Routes**

The routing rules are processed from the top and down, until a match is found - when a match occurs, no more routes are processed. In other words, you should have your most specific rules at the top, and then keep the less specific/catch-all route(s) at the bottom.

```csharp
app.UseMvc(routes =>  
            {  
                routes.MapRoute("Products", "Products/{action=Index}/{id?}", new { controller = "Products" });  
                routes.MapRoute("Default", "{controller=Home}/{action=Index}/{id?}");  
            });
```
<br />

**Attribute routing**

Define a route directly on the responsible Controller and/or specifically for the responsible action/method.
This defines the route for the index method.
```csharp
[Route("/products")]  
public class ProductController : Controller  
{         
    public IActionResult Index()  
    {  
        return Content("Products Index");  
    }  
}
```
```html
http://server/products/
```

<br />

The Details method. It uses a special syntax for defining variable content. 
It allows us to specify a parameter which will be passed to the responding method. 
Our Controller now supports URL's like this one: /products/42 

```csharp
[Route("/products")]
public class ProductController : Controller
{           
    public IActionResult Index()
    {
        return Content("Products Index");
    }

    [Route("{id}")]
    public IActionResult Details(int id)
    {
        return Content("Product #" + id);
    }
}
```

<br />

**Multiple Attribute Routes**

With that in place, our product details page can now be accessed using both URL's.

```csharp
[Route("/products")]
public class ProductController : Controller
{           
    public IActionResult Index()
    {
        return Content("Products Index");
    }

    [Route("{id}")]
    [Route("/product/{id}")]
    public IActionResult Details(int id)
    {
        return Content("Product #" + id);
    }
}
```
```html
http://server/products/12
http://server/product/12
```

<br />

**Routing Templates**

Here's an example of a routing template where we combine two parameters to create the classical [ID]/[URL_SLUG] URL:

```csharp
public class BlogController : Controller
{
    [Route("blogs/")]
    public IActionResult Index()
    {
        return Content("blogs list here");
    }

    [Route("blogs/{entryId}/{slug}")]
    [Route("blog/{entryId}/{slug}")]
    public IActionResult Blog(int entryId, string slug)
    {
        return Content("Blog entry with ID " + entryId.ToString() + " requested (URL Slug: " + slug + ")");
    }
}
```
```html
/blogs
/blog/153/testing-asp-mvc-routes/
/blogs/153/testing-asp-mvc-routes/
```

<br />

**Catch-all parameters**

A catch-all parameter is created by prefixing the name of the parameter with an asterisk (*) character, like this:

```csharp
[Route("blog/{entryId}/{*slug}")]
public IActionResult Blog(int entryId, string slug)
{
    return Content($"Blog entry with ID #{entryId} requested (URL Slug: {slug})");
}
```
```html
URL:  
/blog/153/testing-the/routing-system/    

Output:
Blog entry with ID #153 requested (URL Slug: testing-asp/mvc-routes)
```

<br />

**Optional Parameters**

sometimes you want to make one or several paramters optional, meaning that they can be omitted without the route failing to match the URL request.
Making the slug part of the URL optional is as simple as adding a question mark (?) to the parameter name:

```csharp
[Route("blog/{entryId}/{slug?}")]
public IActionResult Blog(int entryId, string slug = "") 
{
    return Content($"Blog entry with ID #{entryId} requested (URL Slug: {slug})");
}
```
```html
URL:  
/blog/153/
```

<br />

**Reserved routing names**

* action
* area
* controller
* handler
* page

<br />

<br />

**Routing Constraints**

**Data type constraints**

We have added an int constraint like this: {entryId:int}. Now the URL will only match the route if the entryId parameter is an integer, like this:

```csharp
[Route("blog/{entryId:int}/{slug}")]  
public IActionResult Blog(int entryId, string slug)  
{  
    return Content($"Blog entry with ID #{entryId} requested (URL Slug: {slug})");
}
```
```html
URL:  
/blog/153/testing-the-system/
```

**Data type constraints**

* {**entryId:int**}
* {**isVisible:bool**}
* {**entryDate:datetime**}
* {**weight:double**}
* {**weight:float**}
* {**price:decimal**}
* {**id:guid**}
* {**postId:long**}

<br />

**Length/range constraints**

**min()**
```csharp
[Route("blog/{entryId:min(1)}/{slug}")]  
public IActionResult Blog(int entryId, string slug)  
{  
    ....
```

**max()**
```csharp
[Route("blog/{entryId:max(10)}/{slug}")]  
public IActionResult Blog(int entryId, string slug)  
{  
    ....
```

**range()**
```csharp
[Route("blog/{entryId:range(1, 999999)}/{slug}")]
public IActionResult Blog(int entryId, string slug)
{
    ....
```

**Multiple Constraints**
```csharp
[Route("blog/{entryId:range(1, 999999)}/{slug:minlength(3)}")]
public IActionResult Blog(int entryId, string slug)
{
    ....

[Route("blog/{entryId:int:range(1, 999999)}/{slug:minlength(3):maxlength(50)}")]
public IActionResult Blog(int entryId, string slug)
{
    ....
```


**Regular Expression constraints**

**regex()**
```csharp
[Route(@"blog/{slug:regex(^[[0-9]]{{1,7}}\-[[a-z0-9\-]]{{3,50}}$)}")]    
public IActionResult Blog(string slug)    
{    
    ....
```

<br />




**Models**

**View Models**

View Model

```csharp
public class WebUser
{
	public string FirstName { get; set; }
	public string LastName { get; set; }
}

```


<br />

Controller

```csharp

public class WebUserController : Controller
{
	public IActionResult Index()
	{
		WebUser wu = new WebUser();
		wu.FirstName = "Enter first name";
		wu.LastName = "Enter last name";

		return View(wu);
	}

	[HttpPost]
	public IActionResult Index(WebUser wu)
	{
		return Json(wu);
	}
}
```


<br />

View

```html

@model MVCCoreTutorial.Models.WebUser

@{

}

@using (var form = Html.BeginForm())
{

    <div class="row">

        <div class="col">
            @Html.LabelFor(m => m.FirstName)
        </div>
        <div class="col">
            @Html.TextBoxFor(m => m.FirstName)
        </div>

    </div>

    <div class="row">

        <div class="col">
            @Html.LabelFor(m => m.LastName)
        </div>
        <div class="col">
            @Html.TextBoxFor(m => m.LastName)
        </div>

    </div>



    <input type="submit" value="Save" />
}

```

<br />


**Data Annotations**

ASP.NET MVC comes with the concept of DataAnnotations (sometimes referred to as Model Attributes), which basically allows you to add meta data to a property.
The Display annotation.

```csharp
public class WebUser
{

	[Display(Name = "First Name")]
	public string FirstName { get; set; }


	[Display(Name = "Last Name")]
	public string LastName { get; set; }

}
```


<br />

<br />


**Model Validation**

we talked about DataAnnotations and how they can enrich your Models to work even tighter together with your Views. However, a lot of the available DataAnnotations are actually directly related to the validation mechanisms found in the ASP.NET MVC framework. They will allow you to enforce various kinds of rules for your properties, which will be used in your Views and in your Controllers, where you will be able to check whether a certain Model is valid in its current state or not (e.g. after a FORM submission).

```csharp
[HttpGet]
public IActionResult Index()
{
	WebUser wu = new WebUser();
	wu.FirstName = "Enter first name";
	wu.LastName = "Enter last name";

	return View(wu);
}

[HttpPost]
public IActionResult Index(WebUser wu)
{
	if (ModelState.IsValid)
	{
		//Model state is valid
		return Json(wu);
	}
	else
	{
		//Model state is Invalid
		return Content("Model state is invalid");
	}
}
```


<br />

<br />


**Displaying validation errors**

we talked about DataAnnotations and how they can enrich your Models to work even tighter together with your Views. However, a lot of the available DataAnnotations are actually directly related to the validation mechanisms found in the ASP.NET MVC framework. They will allow you to enforce various kinds of rules for your properties, which will be used in your Views and in your Controllers, where you will be able to check whether a certain Model is valid in its current state or not (e.g. after a FORM submission).

```html

@using (var form = Html.BeginForm())
{

    <div class="row">

        <div class="col">
            @Html.LabelFor(m => m.FirstName)
        </div>
        <div class="col">
            @Html.TextBoxFor(m => m.FirstName)
            @Html.ValidationMessageFor(m => m.FirstName)
        </div>

    </div>

    <div class="row">

        <div class="col">
            @Html.LabelFor(m => m.LastName)
        </div>
        <div class="col">
            @Html.TextBoxFor(m => m.LastName)
            @Html.ValidationMessageFor(m => m.LastName)
        </div>

    </div>



    <input type="submit" value="Save" />
}
```
<br />

We also need to make sure that once the FORM is submitted, and if there are validation errors, we return the FORM to the user, so that they can see and fix these errors. We do that in our Controller, simply by returning the View and the current Model state, if there are any validation errors:

<br />

<br />


**Displaying validation errors**

we talked about DataAnnotations and how they can enrich your Models to work even tighter together with your Views. However, a lot of the available DataAnnotations are actually directly related to the validation mechanisms found in the ASP.NET MVC framework. They will allow you to enforce various kinds of rules for your properties, which will be used in your Views and in your Controllers, where you will be able to check whether a certain Model is valid in its current state or not (e.g. after a FORM submission).

```csharp
[HttpPost]
public IActionResult Index(WebUser wu)
{
	if (ModelState.IsValid)
	{
		//Model state is valid
		return Json(wu);
	}
	else
	{
		//Model state is Invalid
		//return Content("Model state is invalid");
		return View(wu);
	}
}
```
<br />

<br />


Add custom error messages

```csharp
public class WebUser
{
	[Required(ErrorMessage = "The First name is required.")]
	[StringLength(25, ErrorMessage = "The First name cannot be longer than 25 chars.")]
	[Display(Name = "First Name")]
	public string FirstName { get; set; }

	[Required(ErrorMessage = "The Last name is required.")]
	[StringLength(50, MinimumLength = 3, ErrorMessage = "The Last name cannot be longer than 50 chars.")]
	[Display(Name = "Last Name")]
	public string LastName { get; set; }
}
```
<br />

<br />

Displaying a validation summary

```html

@model MVCCoreTutorial.Models.WebUser

@{

}

@using (var form = Html.BeginForm())
{
    
    @Html.ValidationSummary()

    <div class="row">

        <div class="col">
            @Html.LabelFor(m => m.FirstName)
        </div>
        <div class="col">
            @Html.TextBoxFor(m => m.FirstName)
            @Html.ValidationMessageFor(m => m.FirstName)
        </div>

    </div>

    <div class="row">

        <div class="col">
            @Html.LabelFor(m => m.LastName)
        </div>
        <div class="col">
            @Html.TextBoxFor(m => m.LastName)
            @Html.ValidationMessageFor(m => m.LastName)
        </div>

    </div>

    <input type="submit" value="Save" />
}

```
<br />

<br />

**Types of Model Validation DataAnnotations**

<br />

**[Required]**
 
For strings you should have in mind that an empty value will be treated like a NULL value and therefore result in a validation error. This behavior can be changed by using the AllowEmptyStrings property though:

```csharp
[Required(AllowEmptyStrings = true)]
```

<br />

**[StringLength]**



```csharp
[StringLength(50, MinimumLength = 3)]
```

<br />

**[Range]**

With the [Range] attribute, you can specify a minimum and a maximum value for a numeric property (int, float, double etc.). Both a minimum and a maximum is required when you use this attribute

```csharp
[Range(1, 100)]
```

<br />

**[Compare]**

The [Compare] attribute allows you to set up a comparison between the property in question and another property, requiring them to match.

```csharp
[Compare("MailAddressRepeated")]
public string MailAddress { get; set; }

public string MailAddressRepeated { get; set; }
```

<br />

**Specific types**

If your string falls into a specific category, e.g. a phone number, the ASP.NET MVC can supply you with basic validation out of the box.

```csharp
[CreditCard] //Validates that the property has a credit card format.

[EmailAddress] //Validates that the property has an e-mail format.

[Phone] //Validates that the property has a telephone number format.

[Url] //Validates that the property has a URL format.
```

<br />

**Adding Client-side validation**

Validation is performed automatically as soon as you start filling out the FORM and if you click on the Create button, the FORM is only submitted to the server if the FORM appears to be valid. If it is, and then FORM is sent back to the server, it will be server-side validated according to the same rules which you have only specified in one place.

* The first line is just the regular jQuery framework - if you already include this elsewhere, you don't need to include this line
* All references here are for a specific CDN (Content Delivery Network) - you can choose another CDN or download the files and serve them directly from your website
* All references here are for specific versions (jQuery version 3.4.1 and so on) - you may want to check if newer versions are available

```csharp
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-validate/1.19.1/jquery.validate.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-validation-unobtrusive/3.2.11/jquery.validate.unobtrusive.min.js"></script>
```
<br />

**TAG Helpers**

Tag Helpers vs. HTML Helpers

```csharp
@Html.TextBoxFor(m => m.FirstName, new { @class = "form-control", style = "font-weight: bold; font-size: 120%;" })
```

```csharp
<input asp-for="FirstName" class="form-control" style="font-weight: bold; font-size: 120%;" />
```

<br />

**The addTagHelper directive**

To use Tag Helpers in your Views, you need to add support for them. This is done using the addTagHelper directive, either directly in the View where you want to use them, or if you want to use them in all your Views: In the _ViewImports.cshtml file

```csharp
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
```

<br />

**The Form Tag Helper**

* You can easily reference the Controller and the Action to submit the FORM to, or even reference a route
* A hidden Request Verification Token is automatically generated and appended to the FORM, to help protect you against cross-site request forgery

```csharp
<form method="post" asp-controller="Blog" asp-action="UpdateEntry"></form> 
```


<br />

**The Route attribute**

As you can see above, hitting the desired Controller and Action method is easy - you simply specify the name of the Controller and the name of the Action method. However, as an alternative, you may decide to target a specific route - the route will then be responsible for hitting the desired Action.

```csharp
<form method="post" asp-route="UpdateBlogEntry"></form>
```

<br />

```csharp
[Route("Blog/Update", Name = "UpdateBlogEntry")]  
public IActionResult Update()  
{  
    .....
```


<br />

**Appending route parameters**

The route you wish to hit may take one or several parameters which you may need to pass to it from your FORM. This can be done using a syntax like this:

```csharp
asp-route-[parameter-name]="value"
```


<br />

So, if the name of the parameter of your parameter is id, your complete FORM tag could look like this:

```csharp
<form method="post" asp-route="UpdateBlogEntry" asp-route-id="@Model.Id"></form>
```


<br />

**The Label Tag Helper**

This is the Display Data Annotation

```csharp
<label asp-for="FirstName"></label>
```


<br />

**The Input Tag Helper**

One of the most commonly used is the INPUT control, which can take many forms to support various types of input. The most common type is the text input control, which will be rendered as a single-line textbox control. 

```csharp
<input asp-for="Title" />
```


<br />

**The Textarea Tag Helper**

we have the Textarea element. It generally looks like a normal text input element, but it can span multiple lines by default and comes with support for scrollbars - in other words, it's built for longer texts. ASP.NET Core comes with a nice Tag Helper for the Textarea, just like for the Input element, so let's look into it.

```csharp
<textarea asp-for="Description"></textarea>
<textarea asp-for="FirstName" cols="25" rows="3"></textarea>
<textarea asp-for="FirstName" style="height: 40px; width: 200px;"></textarea>
```


<br />

**The Select Tag Helper**



```csharp
<select class="custom-select" asp-items="@(new SelectList(Model.Countries))" asp-for="Countries"></select>
```

<br />

**HttpContext**

ASP.NET MVC makes it easy for you to access all HTTP related functionality by gathering it all in the HttpContext class.
The HttpContext class can be accessed from all of your Controllers. For convenience, you can access HttpContext from a property found on your Controllers called HttpContext. 

<br />

**HttpContext structure**

* **HttpContext.Request** - all members related to the current request, e.g. the QueryString, Forms and so on.
* **HttpContext.Response** - all members related to the Response about to be delivered, e.g. Cookies and response headers
* **HttpContext.Session** - all members related to dealing with Session (generally used to persist data between requests)
* **HttpContext.User** - all members related to dealing with a (potentially) authenticated user

<br />

**Query String (GET data)**

```csharp
/Home/QueryTest?name=Jenna Doe
```

<br />

**Accessing the query string**

* **HttpContext.Request.QueryString** - is basically the raw text string
* **HttpContext.Request.Query** -  allows you to easily access keys and their values


```csharp
public class HomeController : Controller
{
    public IActionResult QueryTest()
    {
        string name = "John Doe";
        if (!String.IsNullOrEmpty(HttpContext.Request.Query["name"]))
        {
            name = HttpContext.Request.Query["name"];
        }
        return Content("Name from query string: " + name);              
    }
}
```

<br />

**Forms (POST data)**

<br />

**Accessing FORM data**

The Form property actually works a lot like the Query property - it acts as a Dictionary with keys and their values
Thanks to the HttpContext class and its Form property, accessing FORM/POST data is very easy in ASP.NET MVC. Using it is usually not necessary, thanks to Model Binding, but it's still useful in some cases.
```html
<form method="post" action="/Home/FormsTestPost">  
    <label for="txtName">Your name:</label>  
    <input type="text" id="txtName" name="UserName" />  

    <label for="txtAge">Your age:</label>  
    <input type="number" id="txtAge" name="UserAge" />  

    <button type="submit">Submit</button>  
</form>
```

```csharp
public class HomeController : Controller  
{  
    [HttpGet]  
    public IActionResult FormsTest()  
    {  
        return View();  
    }  

    [HttpPost]  
    public IActionResult FormsTestPost()  
    {  
        return Content("Hello, " + HttpContext.Request.Form["UserName"] + ". You are " + HttpContext.Request.Form["UserAge"] + " years old!");  
    }  
}
```


<br />

**Cookies**

A cookie is basically a physical, plain-text file stored by the client (usually a browser), tied to a specific website.

<br />

**Setting and reading cookies**

Notice how I now use the Request property instead of the Response, when reading the value back - the reason is that setting a cookie is done by adding information to the response sent to the client, while reading it means that you are pulling information from the request made by the client (a normal browser will automatically send all relevant cookies with each request).

<br />

Add cookie

```csharp
HttpContext.Response.Cookies.Append("user_id", "1");
```

<br />

Read cookie

```csharp
var userId = HttpContext.Request.Cookies["user_id"];
```

<br />

read and set

```csharp
public class CookiesController : Controller
{
    public IActionResult Index()
    {
    if(!HttpContext.Request.Cookies.ContainsKey("first_request"))
    {
        HttpContext.Response.Cookies.Append("first_request", DateTime.Now.ToString());
        return Content("Welcome, new visitor!");
    }
    else
    {
        DateTime firstRequest = DateTime.Parse(HttpContext.Request.Cookies["first_request"]);
        return Content("Welcome back, user! You first visited us on: " + firstRequest.ToString());
    }
    }
}
```


<br />

**CookieOptions**

As an optional third parameter to the Append() method we just used, you can pass an instance of the CookieOptions class

```csharp
CookieOptions cookieOptions = new CookieOptions();  
          
cookieOptions.Expires = new DateTimeOffset(DateTime.Now.AddDays(7));
cookieOptions.Domain = ".mywebsite.com";

HttpContext.Response.Cookies.Append("first_request", DateTime.Now.ToString(), cookieOptions);
```

<br />

**Sessions**

As an optional third parameter to the Append() method we just used, you can pass an instance of the CookieOptions class

```csharp
CookieOptions cookieOptions = new CookieOptions();  
          
cookieOptions.Expires = new DateTimeOffset(DateTime.Now.AddDays(7));
cookieOptions.Domain = ".mywebsite.com";

HttpContext.Response.Cookies.Append("first_request", DateTime.Now.ToString(), cookieOptions);
```

<br />

